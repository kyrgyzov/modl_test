import sys
import numpy as np
import argparse
import os
import psutil
import time
from scipy.sparse import csr_matrix, find
from modl.dict_fact import DictFact


# Parser for passing arguments easily to script
parser = argparse.ArgumentParser(description="Run Online Matrix Factorization as in"
                                             "(https://hal.archives-ouvertes.fr/hal-01431618v2/document)"
                                             "on the human gut samples x hashed k-mers matrices")
parser.add_argument("-d", "--data_dir", required=True,
                    help="directory containing the data (.count.hash.nzi, etc.).")
parser.add_argument("-r", "--res_dir", default="./",
                    help="directory where to store results.")
parser.add_argument("-hpp", "--n_hpp", type=int, default=20,
                    help="number of hyperplanes for k-mers hashing (20 or 30)")
parser.add_argument("--nz_kmers", default="nnzhkmers_nmf.npy",
                    help="Name of file with non-zero hkmers indices."
                    "If not provided, will be computed with count_nz_hk function")
parser.add_argument("-c", "--n_comp", type=int, default=500,
                    help="number of components (so-called eigen-genomes)")
parser.add_argument("--names_f", default="samples_names20.txt",
                    help="Name of file with raw samples data.")
parser.add_argument("--sps_egen", type=float, default=0.5,
                    help="sparsity parameter for components, 1 : l1-norm, 0 : l2-norm"
                    " Sparse matrix (sps_egen=1) means a bio. sample should be"
                    " expressed as a combination of few different eigen-genomes"
                    " (compared to total number of them, n_comp)")
parser.add_argument("--sps_kmers", type=float, default=0.5,
                    help="sparsity parameter for code matrix, 1 : l1-norm, 0 : l2-norm."
                    " Sparse matrix (sps_kmers=1) means an eigen-genome should"
                    " be expressed as a combination of few different hkmers"
                    " (compared to total number, 2**n_hpp)")
parser.add_argument("--save_fmt", default='binary',
                    help="format for saving files (`csv` (slower but safer) or `binary`)")

# Functions to check memory and time usage (unused at the moment)
def printMem():
    """ prints memory used in Gb."""
    pid = os.getpid()
    py = psutil.Process(pid)
    memoryUse = py.memory_info()[0]/(1e9)  # memory use in GB...I think
    print('memory use: %3.3f Gb' % (memoryUse))
    return None

def printt(s):
    """ prints string s with current date and time """
    tms = time.strftime("%d/%m/%Y -- %H:%M:%S")
    print(tms, s)

# Function to count non-zero hkmers in order to restrict to non-zero rows
#(and reduce the dim. of) data matrix passed to NMF
def count_nz_hk(n_hkmer, data_dir, names_list, nnzhkmers_f):
    "counts non-zero hkmers (then we can restrict the matrix to non-zero columns)"

    nz_hkmer = np.zeros(shape=(n_hkmer, ), dtype='bool')

    for (num, name) in enumerate(names_list):
        if num < 0:
            continue
        nzi_f = '%s/%s.count.hash.nzi' % (data_dir, name)
        idxs = np.fromfile(nzi_f, dtype=np.int32, sep='')[:-1:2]
        nz_hkmer[idxs] = True
        # printt(num)
        del idxs

    hkmer_nnz = nz_hkmer.nonzero()[0]
    pc_nnz = len(hkmer_nnz)*100./len(nz_hkmer)
    printt('%2.2f %s of non zero columns with %d hyperplanes. Saving to %s.' % (pc_nnz, '%', n_hpp, nnzhkmers_f))
    np.save(nnzhkmers_f, hkmer_nnz)

    return hkmer_nnz

# Parse arguments
args = parser.parse_args()
res_dir = args.res_dir
# Create result directory if non existing yet
if not os.path.exists(res_dir):
    os.mkdir(res_dir)
data_dir = args.data_dir
n_hpp = args.n_hpp
nnzhkmers_f = args.nz_kmers
names_f = args.names_f
n_comp = args.n_comp
save_fmt = args.save_fmt

n_bio_samples = 176
n_hkmer = 2**n_hpp

# File containing the prefixes of the data files in data_dir.
with open(names_f, 'r') as f:
    names_list = f.read().splitlines()

# Get nonzero hashed k-mers indices from file (obtained with count_nz_hk function)
printt("Get nonzero hashed k-mers indices from file")
if os.path.exists(nnzhkmers_f):
    hkmer_nnz = np.load(nnzhkmers_f)
else:
    hkmer_nnz = count_nz_hk(n_hkmer, data_dir, names_list, nnzhkmers_f)

nb_nzhkmer = len(hkmer_nnz)

# Make dictionary to retrieve original hkmer index once we have factorized.
# nnz_dic = {k : n for (n, k) in enumerate(hkmer_nnz)}
nnz_map = np.zeros(shape=(n_hkmer, ), dtype=int) -1
for (idx, kmer_n) in enumerate(hkmer_nnz):
    nnz_map[kmer_n] = idx

# Load matrix in full format (if it fits in RAM)
printt("Load data matrix")
X = np.zeros((nb_nzhkmer, n_bio_samples), dtype=int)
for (row_idx, name) in enumerate(names_list):
    nzi_f = '%s/%s.count.hash.nzi' % (data_dir, name)
    cond_f = '%s/%s.count.hash.cond' % (data_dir, name)
    idxs = np.fromfile(nzi_f, dtype=np.int32, sep='')[:-1:2]
    vals = np.fromfile(cond_f, dtype=np.int32, sep='')
    X[nnz_map[idxs], row_idx] = vals

#
# MATRIX FACTORIZATION #
#
# Soft sparsity parameters
code_l1_ratio = args.sps_kmers
comp_l1_ratio = args.sps_egen
# Enforcing the factorization to be non-negative
code_pos = True
comp_pos = True
# Number of eigen-genomes
n_components = n_comp
# Other rguments for the DictFact method from modl
reduction = 1
code_alpha = 1
batch_size = 2000
n_epochs = 4
verbose = 4
n_threads = 4

dict_fact = DictFact(reduction=reduction,
                         code_alpha=code_alpha,
                         code_l1_ratio=code_l1_ratio,
                         comp_l1_ratio=comp_l1_ratio,
                         code_pos=code_pos,
                         comp_pos=comp_pos,
                         n_epochs=n_epochs,
                         n_components=n_components,
                         batch_size=batch_size,
                         verbose=verbose,
                         n_threads=n_threads)

# Run the fit method
printt("Run dict_fact.DictFact method from modl")
dict_fact.fit(X)

# Save output results
components_f = "%s/components_nmf_test0.npy" % (res_dir)
code_f = "%s/code_nmf_test0.npy" % (res_dir)
msg = "Save numpy ndarrays to files\n %s and\n %s\n.\
      Beware that the hkmers indices in the factorized matrix are not the \
      original ones but only the non-zero ones \
      (given in %s). Check code if needed" % (components_f, code_f, nnzhkmers_f)
printt(msg)
np.save(components_f, dict_fact.components_)
np.save(code_f, dict_fact.code_)

# # Uncomment the following lines if you want to
# # convert results to the original h-kmers indexing
# code_r = np.zeros(shape=(n_hkmer, n_comp), dtype=np.float32)
# code_r[hkmer_nnz, :] = dict_fact.code_
# code_full_f = "%s/code_nmf_full_test0.npy" % (res_dir)
# np.save(code_full_f, code_r)

# Convert results to sparse format (same as input)
# Save matrix ``eigen-genome x hashed-kmer''
printt("Save matrix ``eigen-genome x hashed-kmer'' to files"
       " in sparse coordinate like format ")
for icomp in range(n_comp):
    compgen = dict_fact.code_[:, icomp]
    (_, nzk, nzv) = find(compgen)
    nzk = hkmer_nnz[nzk]
    compname = "component%d" % (icomp)
    nzi_f = "%s/%s.count.hash.nzi" % (res_dir, compname)
    vals_f = "%s/%s.count.hash.cond" % (res_dir, compname)
    if (save_fmt == 'binary'):
        nzk.tofile(nzi_f, sep='')
        nzv.tofile(vals_f, sep='')
    else:
        nzi_f = "%s.csv" % nzi_f
        vals_f = "%s.csv" % vals_f
        np.savetxt(nzi_f, nzk, delimiter='')
        np.savetxt(vals_f, nzv, delimiter='')
    printt("%d"%(icomp))

# Save matrix ``sample x eigen-genome''
printt("Save matrix ``sample x eigen-genome'' to files"
       " in sparse coordinate like format ")
for (isample, sampname) in enumerate(names_list):
    compsamp = dict_fact.components_[:, isample]
    (_, nzk, nzv) = find(compsamp)
    nzk = hkmer_nnz[nzk]
    nzi_f = "%s/%s.count.factor.nzi" % (res_dir, sampname)
    vals_f = "%s/%s.count.factor.cond" % (res_dir, sampname)
    if (save_fmt == 'binary'):
        nzk.tofile(nzi_f, sep='')
        nzv.tofile(vals_f, sep='')
    else:
        nzi_f = "%s.csv" % nzi_f
        vals_f = "%s.csv" % vals_f
        np.savetxt(nzi_f, nzk, delimiter='')
        np.savetxt(vals_f, nzv, delimiter='')
